### **1. ডিক্লারেশন: `Base obj3 = new Derived();`**

এই লাইনটি কী করছে:

1. **অবজেক্ট তৈরি:**
    
    - `new Derived()` হিপ মেমরিতে `Derived` ক্লাসের জন্য মেমরি বরাদ্দ করে।
    - এই মেমরিতে `Base` ক্লাসের অংশ এবং `Derived` ক্লাসের নিজস্ব অংশ থাকবে।
2. **রেফারেন্স টাইপ এসাইনমেন্ট:**
    
    - `obj3` একটি **Base টাইপের রেফারেন্স**।
    - একটি **Base** রেফারেন্স `Derived` অবজেক্ট ধরে রাখতে পারে, কারণ **Derived IS-A Base**। এটি পলিমরফিজমের ধারণা থেকে আসে।

---

### **2. মেমরি লেআউট**

`Derived` অবজেক্টের জন্য মেমরি নিম্নরূপ বরাদ্দ হয়:

| **মেমরি লেআউট**        |
| ---------------------- |
| **Derived** ক্লাস ডেটা |
| **Base** ক্লাস Data    |
|                        |

এখানে `obj3` টাইপ **Base**, তাই এটি শুধুমাত্র `Derived` অবজেক্টের **Base অংশ** পর্যন্ত অ্যাক্সেস করতে পারে। `Derived` ক্লাসের অতিরিক্ত অংশ `obj3` সরাসরি অ্যাক্সেস করতে পারে না।

---

### **3. মেথড কল: `obj3.Display();`**

#### **কেস ১: `virtual` ছাড়া (স্ট্যাটিক বাইন্ডিং)**

- **কম্পাইল টাইম বাইন্ডিং:** যদি `virtual` ব্যবহার করা না হয়, তাহলে মেথড কল **স্ট্যাটিক্যালি** (কম্পাইল টাইমে) বেঁধে দেওয়া হয়।
- কম্পাইলার শুধুমাত্র **রেফারেন্স টাইপ** দেখে সিদ্ধান্ত নেয়। যেহেতু `obj3` এর টাইপ `Base`, তাই `Base.Display()` কল হবে।
- `Derived` ক্লাসের মেথড **উপেক্ষা** করা হয় কারণ কম্পাইলার রানটাইমে অবজেক্টের আসল টাইপ দেখে না।

#### **Case- 2: `virtual` এবং `override` (ডায়নামিক বাইন্ডিং)**

- **রানটাইম বাইন্ডিং:** যদি `Base` ক্লাসের মেথড `virtual` হয় এবং `Derived` ক্লাস এটি `override` করে, তাহলে মেথড কল **রানটাইমে** নির্ধারণ করা হয়।
- এক্ষেত্রে অবজেক্টের আসল টাইপ (`Derived`) চেক করা হয় এবং `Derived.Display()` কল হয়।

---

### **4. এটি কেন ঘটে?**

- **স্ট্যাটিক বনাম ডায়নামিক বাইন্ডিং:**
    
    - যদি মেথড `virtual` না হয়, তাহলে এটি **স্ট্যাটিক বাইন্ডিং** ব্যবহার করে। কম্পাইল টাইমে রেফারেন্স টাইপ অনুযায়ী মেথড ঠিক হয়।
    - যদি মেথড `virtual` হয়, তাহলে এটি **ডায়নামিক বাইন্ডিং** ব্যবহার করে। রানটাইমে অবজেক্ট টাইপ অনুযায়ী মেথড ঠিক হয়।
- **পলিমরফিজম:**
    
    - পলিমরফিজমের মাধ্যমে একটি **Base রেফারেন্স** একটি **Derived অবজেক্ট** পয়েন্ট করতে পারে।
    - কিন্তু মেথড **`virtual`** না হলে, বেস ক্লাসের মেথড কল হয় কারণ কম্পাইলার কেবল রেফারেন্স টাইপ চেনে।

---

### **5. লো-লেভেল ব্যাখ্যা**

1. **হিপ এবং স্ট্যাক:**
    
    - `new Derived()` হিপ মেমরিতে `Derived` অবজেক্ট তৈরি করে।
    - স্ট্যাক মেমরিতে `obj3` একটি রেফারেন্স হিসাবে থাকে, যা হিপে থাকা `Derived` অবজেক্টের `Base` অংশ পয়েন্ট করে।
2. **ভি-টেবল (vtable):**
    
    - যদি মেথড `virtual` হয়, তাহলে প্রতিটি ক্লাসের জন্য একটি **vtable** (ভি-টেবল) তৈরি হয়।
    - `Derived` ক্লাস যদি `Base` এর `virtual` মেথড **override** করে, তাহলে এর `vtable` আপডেট হয়ে `Derived` মেথড পয়েন্ট করে।
    - **Run time** এ `vtable` দেখে ঠিক করা হয় কোন **Function** call হবে।
3. **নন-ভির্চুয়াল মেথড:**
    
    - **Non - virtual**  method vtable ব্যবহার করে না। **Compile time**  মেথড ঠিক হয়ে যায় **Reference Type** অনুযায়ী।

---

### **উদাহরণ:**

#### **ভির্চুয়াল ছাড়া (স্ট্যাটিক বাইন্ডিং):**
```cs
Base obj3 = new Derived();
obj3.Display(); // Base.Display() কল হবে।

```


#### **ভির্চুয়াল সহ (ডায়নামিক বাইন্ডিং):**
```cs
public class Base
{
    public virtual void Display() { Console.WriteLine("Base Display"); }
}

public class Derived : Base
{
    public override void Display() { Console.WriteLine("Derived Display"); }
}

Base obj3 = new Derived();
obj3.Display(); // Derived.Display() কল হবে।

```



---

### **সংক্ষেপে:**

1. **স্ট্যাটিক বাইন্ডিং:**
    
    - মেথড কম্পাইল টাইমে রেফারেন্স টাইপ অনুযায়ী ঠিক হয়।
    - নন-ভির্চুয়াল মেথড কল হলে বেস ক্লাসের মেথড কল হবে।
2. **ডায়নামিক বাইন্ডিং:**
    
    - ভির্চুয়াল মেথড রানটাইমে অবজেক্টের আসল টাইপ অনুযায়ী ঠিক হয়।
    - ডেরাইভড ক্লাসের মেথড কল হবে।
3. **মেমরি লেআউট:**
    
    - হিপে অবজেক্ট তৈরি হয় এবং রেফারেন্স স্ট্যাকে থাকে।
    - নন-ভির্চুয়াল মেথড রেফারেন্স টাইপ অনুসরণ করে।
    - ভির্চুয়াল মেথড vtable ব্যবহার করে রানটাইমে অবজেক্ট টাইপ অনুযায়ী কাজ করে।